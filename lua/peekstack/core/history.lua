local M = {}

local DEFAULT_MAX_HISTORY = 50

-- Lazy-loaded dependencies (same pattern as stack.lua).
local config, layout, popup, user_events
local function deps()
  if not config then
    config = require("peekstack.config")
    layout = require("peekstack.core.layout")
    popup = require("peekstack.core.popup")
    user_events = require("peekstack.core.user_events")
  end
end

---Build a history entry from a popup model.
---@param item PeekstackPopupModel
---@param idx integer  position in the stack at close time
---@return PeekstackHistoryEntry
function M.build_entry(item, idx)
  return {
    location = item.location,
    title = item.title,
    title_chunks = item.title_chunks,
    pinned = item.pinned,
    buffer_mode = item.buffer_mode or "copy",
    source_bufnr = item.source_bufnr,
    created_at = item.created_at,
    closed_at = os.time(),
    restore_index = idx,
    parent_popup_id = item.parent_popup_id,
  }
end

---Insert a history entry into the stack and enforce max_items limit.
---@param stack PeekstackStackModel
---@param entry PeekstackHistoryEntry
function M.push_entry(stack, entry)
  deps()
  local max_history = config.get().ui.popup.history.max_items or DEFAULT_MAX_HISTORY
  table.insert(stack.history, entry)
  if #stack.history > max_history then
    table.remove(stack.history, 1)
  end
end

---@param event string
---@param popup_model PeekstackPopupModel
---@param root_winid integer
local function emit_popup_event(event, popup_model, root_winid)
  deps()
  user_events.emit(event, user_events.build_popup_data(popup_model, root_winid))
end

---Restore a history entry into the stack.
---@param stack PeekstackStackModel
---@param entry PeekstackHistoryEntry
---@return PeekstackPopupModel?
function M.restore_entry(stack, entry)
  deps()
  local create_opts = {
    buffer_mode = entry.buffer_mode or "copy",
    origin_winid = stack.root_winid,
    parent_popup_id = entry.parent_popup_id,
  }
  -- Only pass title override for user-renamed popups (no title_chunks).
  -- Auto-generated titles are regenerated by build_title() to preserve
  -- structured chunks for popup window and stack view highlighting.
  if not entry.title_chunks then
    create_opts.title = entry.title
  end

  -- For source mode, check if the source buffer is still valid
  if create_opts.buffer_mode == "source" and entry.source_bufnr then
    if not vim.api.nvim_buf_is_valid(entry.source_bufnr) then
      -- Fallback to copy mode if source buffer is gone
      create_opts.buffer_mode = "copy"
    end
  end

  local model = popup.create(entry.location, create_opts)
  if not model then
    return nil
  end
  model.pinned = entry.pinned or false

  local restore_position = config.get().ui.popup.history.restore_position or "top"
  if restore_position == "original" and entry.restore_index then
    local insert_idx = math.min(entry.restore_index, #stack.popups + 1)
    table.insert(stack.popups, insert_idx, model)
  else
    table.insert(stack.popups, model)
  end

  stack.focused_id = model.id
  layout.reflow(stack)
  emit_popup_event("PeekstackPush", model, stack.root_winid)
  user_events.emit("PeekstackRestorePopup", user_events.build_popup_data(model, stack.root_winid))

  return model
end

---Restore the last closed popup from history (undo close).
---@param stack PeekstackStackModel
---@return PeekstackPopupModel?
function M.restore_last(stack)
  if #stack.history == 0 then
    return nil
  end
  local entry = stack.history[#stack.history]
  local restored = M.restore_entry(stack, entry)
  if not restored then
    return nil
  end
  table.remove(stack.history)
  return restored
end

---Restore all closed popups from history.
---@param stack PeekstackStackModel
---@return PeekstackPopupModel[]
function M.restore_all(stack)
  local restored = {}
  local remaining = {}
  while #stack.history > 0 do
    local entry = table.remove(stack.history)
    local model = M.restore_entry(stack, entry)
    if model then
      table.insert(restored, model)
    else
      table.insert(remaining, 1, entry)
    end
  end
  stack.history = remaining
  return restored
end

---Restore a specific history entry by index back into the stack.
---@param stack PeekstackStackModel
---@param idx integer  index in the history list (1-based)
---@return PeekstackPopupModel?
function M.restore_from_history(stack, idx)
  if idx < 1 or idx > #stack.history then
    return nil
  end
  local entry = stack.history[idx]
  local restored = M.restore_entry(stack, entry)
  if not restored then
    return nil
  end
  table.remove(stack.history, idx)
  return restored
end

---Get the history list for a stack.
---@param stack PeekstackStackModel
---@return PeekstackHistoryEntry[]
function M.list(stack)
  return stack.history
end

---Clear the history for a stack.
---@param stack PeekstackStackModel
function M.clear(stack)
  stack.history = {}
end

return M
